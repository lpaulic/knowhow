# [TitleThe Pragmatic Programmer: Your Journey To Mastery](https://www.amazon.com/Pragmatic-Programmer-journey-mastery-Anniversary/dp/0135957052)

![The Pragmatic Programmer: Your Journey To Mastery cover](https://m.media-amazon.com/images/I/71f743sOPoL._SL1500_.jpg "The Pragmatic Programmer: Your Journey To Mastery cover")

## Details
- Author: Andrew Hunt, David Thomas
- Rented to: No

## Quotes

> *"... you can change your organization or change your organization" -- Martin Fowler*

> *"I'm not in this world to live up to your expectations and*
> *you're not in this world to live up to mine"* -- Bruce Lee

> *"Striving to better, often we mar what's well." -- Shakespeare King Lear 1.4*

> *"... the painting becomes lost in the paint" -- Painters*

## Key tekeaways

### What makes a pragmatic programmer:
An pragmatic programmer is:
- Early adopter / fast adapter
- Critical thinker
- Realistic
- Jack of all trades
- Thinks of the bigger picture
    - Helps to craft good-enough software
- Responsible

Chapters: Preface 

### Craft not a job

It is your life so you are in charge and you have control. If you
are not learning things, don't wait for your employer to find time use our
own, it is your life in the end, you are responsible.

In the software engineering profession one of the cornerstones of pragmatism is
to take responsibility for yourself, your actions in terms of career advancements,
your learning and education, your project, and your day-to-day work.

Trust from your team is the other tremendously important aspect. The team needs
to trust you and be able to rely on you and vice versa. Where there's trust, there
is honesty and loyalty.

Responsibility is a commitment that somethings is done right, even if you are
not directly controlling it. You must analyze the situation for the risks that
are out of your control. You have the right not to take responsibility for an
impossible situation, or one in which the risk is to grate, or the ethical
implications to sketchy. If you do accept than you are accountable for the
outcome. If you do make a mistake do not blame others, admit it review it
and offer solutions.

Chapters: It's Your Life, The Cat Ate My Source Code, 

### Take care of the software

In Physics *Entropy* refers to the amount of "disorder", and unfortunately the
laws of thermodynamics guarantee that the entropy tends to a maximum. Although
software is not govern by physic entropy is software is real. In software it is
also referred to as *"software rot"* or *"technical debt"*.

We as pragmatic programmers can not let the entropy spread. From many contributors
to software rot the most notable is routed in project psychology, or culture at work
on a project. The project psychology, even in team-of-one is a delicate thing and
even amongst well crafter processes and well behaved engineers a project can still
face ruin and decay in its lifetime. What makes the difference, according to the
[researches in the field of crime and urban decay [1](#references),
a broken window. A broken window if not fixed in a certain period of time causes
a sense of abandonment in people, a sense if not dealt with causes neglect
where one broken window leads to two, littering, graffiti, etc. And soon
the building really is abandoned.

Why does that make a difference, scientists have done
studies [2](#references) that show haplessness can be
contagious. So the conclusion is do not leave broken windows in code (bad design,
wrong decision, bugs, etc.). Even if it can not be fix because of time, patch
it up and leave a comment for refactor.

The most important thing is: do no harm. Anecdote where fireman went to
extinguish a fire in a immaculate house. After getting to the house and
assessing the situation, they put a carpet from the entrance to the fire
to not mess up the floor and existing carpet. Moral of the story don't
cause more harm than there is. Do not degrade existing code while trying
to fix something urgently (for a showcase, deadline, release date)
respect the current excellent state. The urgency is not worth degrading
a good code.

When handling urgent situations and software rot tell
yourself: "No broken windows".

Chapters: Software Entropy 

### Learn how to talk to people

Story about soldiers coming to a war affected village, and start preparing a soup
from three stones. The villagers gather round and were amazed. They asked if that's
all that goes in the soup. The soldiers stated that additional ingredients would make
it better. After hearing that a missing ingredient the soup would be better a villager
ran to his house and brought the missing ingredient from his personal hoarded stash.
One by one villager asked the same question and the soldiers replied with a new
ingredient. Before you know it they had a soup with loads of ingredients. When the soup
was done the soldiers removed the stones.

The moral of the story is that although the soldiers tricked the villagers in the end
it was for everybody's benefit. Some times you need to be as the soldiers a catalyst.
You also need to be aware of your soroundings to not be blind sided as the villagers,
especially if the fate is bad for us.

In a situation you may know what needs to be done but asking permission to tackle the
whole thing you'll be met with delays and blank stares. Work out
what you can reasonably ask for, develop it and present it. Make the people admire it.
Than plant the seed: "it would be better if ...". Pretend it is not important.
Be a catalyst for change.

It is the accumulation of small things that break morale and teams.
Always remember the big picture.

Chapters: Stone Soup and Boiled Frogs

### Good enough software

In the article IEEE Software, When good-enough software is best [3](#references)
by Ed Yourdon. You can discipline yourself to write software that is good-enough --
good enough for your users, future maintainers, for your peace of mind. This leads
to more productive personal work, happier users and better programs. But what does it
mean "good enough" software. If definitely does not mean sloppy or poorly produced code.
All systems must meed their requirements, basic performance, privacy and security
standards. We simply want to include the user in the process of deciding when the
program is good-enough for their needs.

Make quality a part of system requirements during scope and quality discussions.

It is better to have a unpolished software today than a perfect software
tomorrow. This is an art to restrain yourself to stop when needed.

Chapters: Good-enough software

### Build your knowledge

Software engineer's knowledg is an asset and it should be managed linke one:
1. Serious investors invest regularly - as a habit.
2. Deversification is the key to long-term success.
3. Smart investors balance their portfolios between conservative and high-risk,
high-reward investments.
4. Investors try to buy low and sell high for maximum return.
5. Portfolios should be reviewed and rebalanced periodically.

In terms of software engineering that could mean something down the line like:
1. Learn at least a new programming language every year.
2. Read a techincal book each month.
3. Read non techinacal books too.
4. Take classes.
5. Participate in local user groups and meetups.
6. Experiment with different environments.
7. Stay current.

After all that rembemer be critical about what you hear and read. Don't let 
your knowledge base sway based on what vendors and media hype state. It must 
be accurate. Never underestimate the commercialism. Critical thinking is 
a study on its own. **Study all you can about it**. A few quide lines to use:
1. Ash the "Five Whys"
2. Who does this benefit?
3. What is the context?
4. When and Where would this work?
5. Why is this a problem?

Chapters: Your Knowledge Portfolio

### Be a good communicator

Software engineers must know how to communicata on different levels and to different
audinece. The commincation must result in conveying the neccesarry information
to parties involved. How to do it depends on the audience.

Knowing your audinece helpse the communicaiton chain. Focus on topics and aspects
on what you try to say based on the feild of interest of the audinece you are speeking 
to.

Know what to say as well. Ask yourself: "Does this communicate what I want to express 
to my audience in the way that works for them?". Refine until it does.

Chosing the moment when to communicate matters as well. Sharing potentinal hard 
news to someone who already has a hard time will not provide the best result. 
Also when there is a situation ongoing for which you have a solution, than 
it is the time to communicate.

Chose a style that best resonates whith your audience. This is best understood
when speaking to one person. If they like straight to the point then communicate
like that. If they like to talk about something else before do that.

Make it look goot. Wether a written document or speaking. Make an effort that it 
looks the part.

Involve the audinece by geeting feedback. Ask questions or provide documentation 
to be review. Do it frequently.

If you want people to listen to you you must listen to them. To show them that you 
are listening ask questions in response to their questions. Even if you have all 
the information listen. Ask them to give their perspective on this situation.

Get back to people. Regardless if you have time or not respond. Use the:
"I'll get back to you later ...", so that people are informed.

Even in written form, meaning the documentation or mails or whatever, do not let 
it be an afterthouhgt. Pragmatic programmers build the documentaiton in, not bolt
it on the project. That doesn't mean to write documentation to every funciton, 
data structure or others. Even in the documentation the DRY (Don't Repeant Yourself)
applies. Focuse on the things that are not clear: trade-offs, why's, discarded alternatives.

A sepparate descision log document can exists to provide detailed explanation and not 
put that in the code.

Chapters: Communicate!

### Pragmatic approach

Focus on good design, because good design is allways simpler to change than bad design.
To guide you trhough it use the following ideas:
- ETC (Eassier To Change)
- DRY (Don't Repeat Yourself)
- Orghogonality
- Reversability
- Tracer Bullets
- Prototypes

Focus on the solution to be ETC, this is the essence of good design. It is not easy to 
create things that are ETC and it involves a lot of frequent thinging solved and 
unsolved problems. ETC is an value not a rule, there is no blueprint on how to 
create ETC solutions, it is simply something you always check when working on something:
"Is this solution easier to change down' the line than a different solution."
This is important to note because the requirements (descriptions of the real world) can 
change, and our solution has to be able to change as well as simple as possible.
A guide on how to make descisions on what path will be easier to change in the future:
- common scenece and experiene -> good educated gues
- try to make the solution easiliy replaceble
- note the situaitons that required an analisis to get to a ETC descision in engineering day-book.
Note the choices (paths) that are available in the moment, and some guesses abut change.
Deffinetely, propose if not already, have a descision log that will hold the ETC descision on 
project level.

DRY is an crutial step in beeing pragmatic. It focuses on not repeting knowledge. This 
does not necessary always meand that two places with same lines are code have the 
same knoledge. Remeber see the bigger picture and focus on the context.
DRY spans acrous functions, expressions, data and documentation. Yes, documentation,
in code don't write comments that say the same thing as the code but just in English.
That is dupplication. Reduce DRY violations when using internal/external APIs or libraries.
For internal APIs utilize API tools that let you specify APIs ina neutral format
(not language related). Find tools that generate documentation as well, mock APIs,
functional tests and API clients. For external APIs, ofthen they utilize the 
OpenAPI[4](#references) standard. The implementaitonos of OpenAPI can be found here[5](#refernces)
If no API specs can be found create one an publish it to OpenAPI.
DRY can be violated in data source representations, this can be resolved by using the two layer
approach. On one layer use key/value representation available in the used language (array of key/val structures,
maps, hash, dictionary, object). The second layer describes the data type we are working with, this 
is done by a table-driven validaton suite that verifies that the map created in layer one
contains at least the data you need in the format you need. This doesn't have to be 
a single entity but scattered in modules that use the data sources.
Another option is to use frameworks that use schemas the desribe the data sources and generate
the data source containers in the language of choice if it is supported. This uses more resources
but it can be used, make sure it is hidden on the layer closes to the data sources
so it can be replaced if needed.

But DRY goes further than code and documentaiton, it can span between engineers on a project.
Multiple implementations of the same funcionality can be created and be undetected for years.
To solve this incourage active and frequent communicaiton between engineers. Possible solutions:
- have once a week meetings or post where problems and their solutions are shared, this 
is for developers

Orthogonality is important in a pragmatic approach to software. The term is borrowed from 
geometry and it means that if two lines meet at a right angled they are orghogonal. In vector
terms they are independent. In computing terms orthogonality means that two systems/modules are 
indenepnant from each other -> changes to one doesn't affect the other.

Eliminate effects between unrelated things. In the book from Yourdon and Constantine[6](#references)
define a coheised design as ona that focues on self-contained components: independent, and 
with a single well-defined purpose. This isolation ensures thath:
- pruductivity goes up: estimation, development, testing is incresed because the component is small
- reduced risk: changes to an independent component don't affect others
- desing: focus on modular, component-based and layerd design

Watch out for toolkits and libraries, when integrating 3rd-party or from different teams be critical:
does it impose changes that shouldn't be there -> create non-orthogonal, non-DRY code. In any case
isolate it behind abstractions so it abliges to ETC.

Guieds for coding to keep code orthogonal:
- keep your code decoupled
- avoid global data (i.e.: Singledot objects as globals)
- avoid similar functions
    - same entry/exit different algorithm -> structural problems
    - Strategty pattern

It is easier to test orthogonal code than non-orthogonal. This is the case 
becase the interactions between other components is formalized and limited.
These modules can be tested individually -> module test = unit test.

Keep code that does the same thing (same knowledge) together-> cohesion.
Keep code that do not the same thing isolated -> decoupled.

Orthogonality applies to documentation. One axis is content the other is 
presentation.

Reversibility is part of the pragmatic approach. Critical decisions aren't
easily reversible. This is the pragmatic programers job to use his brain
to ensure that those critical decisions don't end up ireversible. To do that
abstracions is necessary. Hide the specific details tide to the vendor, 
librari, API that was a critical decision behind layers. So if change 
is needed only that module changes. This applies to databases, UIs, and other
endpoints and data sources. The importat part is to design the connectivity
to be uneffected by the changes of bottom layers. This is also hard 
because a generic relation between the interfaces must exist that is ETC
also. Remember: "There are no final decisions".

Architecture, deployment and vendor integration must be flexible not just
the code. These aspects define the code. Architecture changes as well
and it can't be followed, but it can be mitigated. Use abstraction, layers
and brake code in componetets, this will enable easier sepparation
from monolith architecture to service architecture. The interfaces 
between them will have different implementations, the trick is 
to define good APIs that can stay uneffected. But even if that is not done, 
but is split into components it is easier to update the connection logic, that
will then support both architectures.

Tracer bullte development is a good approach when doing something where the 
outline of the idea is know but the specifics are not (libraries, integrations, etc.).
This approach helps to guide the project from start to finish by implementing the simplest
feature that tighs all the layers together (UI, bussines logic, data model, databases, etc.).
The product of the MVP received with tracer bullet development is that it is not thown away
, like prototypes, but it is kept and built upon. The tracer bullet development follows 
are the guide lines for proper development: documentaiton, test, checking, etc. but it simply
does that on the feature that tights most of the components togeter.
Advanteges of tracer bullet development (traer coe approach):
- Users get to see something working early
- Developers build a structure to work in
- You hava an integration platform
- You have something to demonstrate (allways)
- You have a better feel for the progress

Prototypes on the other hand are ment to be used whent we are not certain in how it will 
work in the real world and it is to expensive to try tracer bullet approach. Prototyes
are cheeper becuse they focus only on one or few aspects that they want to test. 
Programming practices are not used in order to get the result of testing quick, but 
that is OK because the code in prototypes are either dropped or revised if it gave 
a desired result. Main point use prototypes where ther is high risk, hasn't been 
tried or is criticalto the final system. Anyting unproven, experimental, doubtful:
- Architecture
- New functionality in existing system
- Structure or contents of external data
- Third party tools or components
- Performance issues
- User interface desing

The details that are ignored in prototypes:
- Correctnes: dummy data can be used
- Completeness: limited functionality
- Robusteness: incomplete or no error checking
- Style: no comments, common practices only documents that provide prototype experience gained

Areas to look for in architectural prototypes:
- Are the responsibilities of the major areas well defined and appropriate?
- Are collaborations between major components well defined?
- Is coupling minimized?
- Can you identify potential sources of duplication?
- Are interface definitions and constraints acceptable?
- Does every module have an access path to the data it needs during execution?
Does it have access when it needs to?
- Is it ETC?

Domain languages are used when describing the problem into code. The idea is to 
use the language close to the problem domain. If you want to describe how the system
behaves a pseudo-like language might be the best file like:
- [RSpec](https;//rspec.info) 
- [Cucumber](https://cucumber.io)

When writing netowork applications having requests and responses 
specified as routes and filters and responses is better than codding 
it in a programming language way, i.e.: [Phoenix Routes](https://phoenixframework.org/)

Setting up an server is also better if you could have a specification 
written in one language and the whole configuration is done automatically.
The language for this is: [Ansimble](https://www.ansible.com)

Use the languages the describe the problem more natural to the domain.

The general tip is: *Program Close to the Problem Domain*.

Estimating is important to avoid suprises with non-techincal 
people that you are working with. All estimates will never be 
100% accurate, they are after all estimates. To have a more accurate estimate 
more time has to be invested to analyze the problem. It is important to know 
who is asking for the estimate, and how accurate they want it.

Formating the estimate in appropriate units is also important. If you estimate in 
days people will expect it do be done fairly quickly, even if you estimate 
140 working days, which is ~5 months. Below is a table to depict how communicate
estimates:
- 1-15 days -> Days
- 3-6 weeks -> Weeks 
- 8-20 weeks -> Months
- 20+ weeks -> Think hard before giving an estimate

Estimates are based on the models of the problem. To have a good estimate 
a good model of the problem has to exists. But before discussing how 
to build a good model, the best trick for a good estimate: 
**Ask someone who has already done it.**
Most likely you won't get the same match to your problem, but 
check what was their problem and how they dealth with it. Than you 
can compare it to yours and estimate for the differences based on 
experience.

Allways think about the scope of the domain and the scope of the 
particular problem you are estimating. This will never be directly 
presented in a question but you must take it into account.

The model of the system is the high-level representation of the 
system and the environment it is used. It is usefull to have 
for discussions with non-tech poeople or when discussing 
solutions with the team. The more detail in the model 
the more accurate the estimation. But it takes more time 
to build a detailed model. So be ware of the trade off.

Separate the model in components and discover the rules 
that describe the componentes. The relationship with other 
models, usually described with mathematics.

Each component will have parameters that affect how 
the component affect the model. Assing values to each 
parameter. These values will have errors but the goals is 
work out which paramters have most impact on the result 
and assing them correctly. For example parameters that 
multiply with something have a bigger impact than those 
who add to something.

There should be a justifiable way of calculating these 
parameters and they should be written down so they can be 
used to back up your descisions and so people who get to the 
project after you know what has been done. Best way 
to get these parameters is to do some measurements on 
a prototype, or a similar system.

The answers will rarely be simple, or a one number answer.
They will always be tight to a scenario and varie to the 
various inputs of the environemnt and the model.

Last important note is to adjust the estimates and 
schedule after every iteration where the code is changed.
More knowledge will be gained, more things will become clear 
and the estiamates should be updated to reflect that. 

Chapters: The Essence of Good Design, DRY, Orthogonality, Tracer Bullets,
Prototypes and Post-it Notes, Domain Languages, Estimates

### Tools of a Pragmatic Programmer

## References

1. [Broken window experiment](https://www.theatlantic.com/magazine/archive/1982/03/broken-windows/304465/) 
2. [Hopelessnes studie](https://pubmed.ncbi.nlm.nih.gov/7932064/) 
3. [IEEE Software, When good-enough software is best](https://www.computer.org/csdl/magazine/so/1995/03/s3079/13rRUzpQPLU)
4. [OpenAPI](https://github.com/OAI/OpenAPI-Specification)
5. [OpenAPI implementations](https://tools.openapis.org/categories/documentation.html)
6. [Structured Design: Fundementals of a Discipline of Computer Program and System Design](https://www.amazon.com/Structured-Design-Fundamentals-Discipline-Computer/dp/0138544719)
7. [Design Patterns: Elements of Reusable OO Software](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/B09L3Y5JBL)

